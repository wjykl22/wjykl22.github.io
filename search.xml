<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>粉笔公考-判断推理-图形推理</title>
    <url>/archives/487a2936.html</url>
    <content><![CDATA[<h2 id="判断推理题型">判断推理题型</h2>
<ul>
<li>图形推理</li>
<li>类比推理</li>
<li>定义判断</li>
<li>逻辑判断</li>
</ul>
<h2 id="图形推理">图形推理</h2>
<h3 id="命题形式">命题形式</h3>
<h4 id="一组图">一组图</h4>
<p>大多数：从左到右整体去看</p>
<p>有时候：跳着看，考地相对较少</p>
<p><img src="/archives/487a2936/image-20200727205210815.png" alt="image-20200727205210815" style="zoom:67%;"></p>
<h4 id="两组图">两组图</h4>
<p>第一组用于找规律，第二组用规律（模仿第一组的规律即可，细节变化以第二组图为准）</p>
<p><img src="/archives/487a2936/image-20200727205147584.png" alt="image-20200727205147584" style="zoom:67%;"></p>
<h4 id="九宫格">九宫格</h4>
<p>优先横着看，其次再是竖着看（很少斜着、S型和米子型）</p>
<h4 id="分组分类">分组分类</h4>
<p>一般分成两组，在组内找出各自的规律（找出两个规律）</p>
<p><img src="/archives/487a2936/image-20200727205400400.png" alt="image-20200727205400400" style="zoom:67%;"></p>
<h4 id="空间类折纸盒">空间类：折纸盒</h4>
<p>六面体为主，转化成平面</p>
<p><img src="/archives/487a2936/image-20200727205533123.png" alt="image-20200727205533123" style="zoom:67%;"></p>
<h5 id="特殊题型">特殊题型</h5>
<ul>
<li>截面图</li>
<li>三视图</li>
<li>立体拼合</li>
</ul>
<h2 id="六大规律">六大规律</h2>
<p>重点通过识别图形特征，来识别考察什么规律</p>
<ol type="1">
<li>位置规律</li>
<li>样式规律</li>
<li>属性规律</li>
<li>特殊规律</li>
<li>数量规律</li>
<li>空间规律</li>
</ol>
<h3 id="位置规律">位置规律</h3>
<h4 id="特征">特征</h4>
<p>位置类识别特征：各图元素组成相同</p>
<p><img src="/archives/487a2936/image-20200727210022937.png" alt="image-20200727210022937" style="zoom:67%;"></p>
<h4 id="考点">考点</h4>
<ul>
<li>平移</li>
<li>旋转、翻转（常结合考察）</li>
</ul>
<h5 id="考点一平移">考点一：平移</h5>
<ol type="1">
<li><p>方向：直线（上下、左右、对角线）、绕圈（顺/逆时针）</p>
<p><img src="/archives/487a2936/image-20200727210259617.png" alt="image-20200727210259617" style="zoom:67%;"></p></li>
<li><p>步数：恒定、递增（等差）、周期（考的少）</p></li>
</ol>
<h6 id="宫格形黑块平移">宫格形黑块平移</h6>
<ol type="1">
<li>个别黑块重合
<ul>
<li>题干和选项大部分元素组成完全一致，个别一两副图少黑块</li>
<li>题干第一幅图的黑块一般不会重合</li>
</ul></li>
</ol>
<p><img src="/archives/487a2936/image-20200727210936304.png" alt="image-20200727210936304" style="zoom:67%;"></p>
<ol start="2" type="1">
<li><p>黑块走到头后</p>
<ul>
<li><p>循环走：从头开始</p>
<p><img src="/archives/487a2936/image-20200727211118319.png" alt="image-20200727211118319" style="zoom:67%;"></p></li>
<li><p>折返走：直接弹回</p>
<p><img src="/archives/487a2936/image-20200727211135729.png" alt="image-20200727211135729" style="zoom:67%;"></p></li>
<li><p>“双胞胎”黑块如何分辨：就近走原则</p>
<p><img src="/archives/487a2936/image-20200727211331662.png" alt="image-20200727211331662" style="zoom:67%;"></p></li>
</ul></li>
</ol>
<h6 id="多宫格方向判定">多宫格方向判定</h6>
<p>题型特征：16宫格图形多个黑块平移</p>
<ol type="1">
<li><p>直线走：</p>
<ul>
<li>横行黑块数量相同（左右走）</li>
<li>竖行黑块数量相同（上下走）</li>
</ul>
<p><img src="/archives/487a2936/image-20200727211823656.png" alt="image-20200727211823656" style="zoom:67%;"></p></li>
<li><p>绕圈走：</p>
<ul>
<li>中间颜色数量相同，有限考虑内外圈分开看</li>
</ul>
<p><img src="/archives/487a2936/image-20200727212331968.png" alt="image-20200727212331968" style="zoom:67%;"></p></li>
</ol>
<h5 id="考点二旋转与翻转">考点二：旋转与翻转</h5>
<h6 id="旋转">旋转</h6>
<ol type="1">
<li>方向：顺时针、逆时针</li>
<li>常见角度：45°、60°、90°、180°等</li>
</ol>
<blockquote>
<p>TIPS：难题可以采用两两相邻比较</p>
<p>钟表类：麦面一个框，中间有一个点，饶了一圈线——常考旋转</p>
</blockquote>
<h6 id="翻转">翻转</h6>
<ol type="1">
<li>左右翻转</li>
<li>上下翻转（可能存在视觉误差，需要警觉）</li>
</ol>
<blockquote>
<p>TIPS：先看容易看懂的</p>
</blockquote>
<p>这道题目需要注意上下翻转，很难看出来（第二张图到第三张图）</p>
<p><img src="/archives/487a2936/image-20200727214018551.png" alt="image-20200727214018551" style="zoom:67%;"></p>
<h6 id="区分旋转和翻转">区分旋转和翻转</h6>
<ul>
<li><p>只有左右互换（上下不变）——左右翻</p>
<p><img src="/archives/487a2936/image-20200727214319546.png" alt="image-20200727214319546" style="zoom:67%;"></p></li>
<li><p>只有上下互换（左右不变）——上下翻</p>
<p><img src="/archives/487a2936/image-20200727214353319.png" alt="image-20200727214353319" style="zoom:67%;"></p></li>
<li><p>上下、左右都互换——旋转180°</p>
<p><img src="/archives/487a2936/image-20200727214429063.png" alt="image-20200727214429063" style="zoom:67%;"></p></li>
</ul>
<h3 id="样式规律">样式规律</h3>
<h4 id="特征-1">特征</h4>
<p>样式识别特征：元素组成相似</p>
<h4 id="考点-1">考点</h4>
<ol type="1">
<li>遍历</li>
<li>加减同异</li>
<li>黑白运算</li>
</ol>
<h5 id="考点一遍历">考点一：遍历</h5>
<p>图形特征：小元素重复出现</p>
<p>解题思路：缺啥补啥（遍历包括空白/阴影等很多方面）</p>
<p><img src="/archives/487a2936/image-20200727215015137.png" alt="image-20200727215015137" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>公务员考试</category>
        <category>判断推理</category>
      </categories>
      <tags>
        <tag>国考</tag>
        <tag>行测</tag>
        <tag>判断推理</tag>
        <tag>图形推理</tag>
        <tag>类比推理</tag>
        <tag>定义判断</tag>
        <tag>逻辑判断</tag>
      </tags>
  </entry>
  <entry>
    <title>DOUBLESQUEEZE Parallel Stochastic Gradient Descent with Double-pass Error-Compensated Compression</title>
    <url>/archives/493c0bc7.html</url>
    <content><![CDATA[<h2 id="摘要">摘要</h2>
<p>目前已有类似于QSGD和稀疏化SGD的通信优化算法，但参数服务器在实际应用中在收到工作节点量化梯度并聚合后，需要将聚合梯度从新分发给工作节点。本论文同时对工作节点和参数服务器梯度，采用误差补偿的方式进行梯度压缩。该算法有三大优势：</p>
<ol type="1">
<li>它兼容众多“粗暴”的压缩技术</li>
<li>它与没有误差补偿的压缩算法（例如QSGD和稀疏化SGD）相比，收敛性更好</li>
<li>达到了线性收敛</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"111"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dfdfadf</p>
</blockquote>
<h2 id="背景介绍">背景介绍</h2>
<p>提高分布式机器学习性能的三个方向：</p>
<p>（1）高通信效率的学习</p>
<ul>
<li>QSGD: Communication-efficient SGD via gradient quantization and encoding<a href="#refer-anchor-1"><sup>1</sup></a>（量化为三元组表示）</li>
<li>signSGD: Compressed optimisation for non-convex problems<a href="#refer-anchor-2"><sup>2</sup></a></li>
<li>1-bit stochastic gradient descent and its application to data-parallel distributed training of speech dnns<a href="#refer-anchor-3"><sup>3</sup></a>（提出一种误差补偿的量化方法）</li>
</ul>
<p>（2）去中心化学习；</p>
<ul>
<li>He L, Bian A, Jaggi M. Cola: Decentralized linear learning[C]//Advances in Neural Information Processing Systems. 2018: 4536-4546.</li>
<li>Lian X, Zhang C, Zhang H, et al. Can decentralized algorithms outperform centralized algorithms? a case study for decentralized parallel stochastic gradient descent[C]//Advances in Neural Information Processing Systems. 2017: 5330-5340.</li>
</ul>
<p>（3）异步学习</p>
<ul>
<li>Agarwal A, Duchi J C. Distributed delayed stochastic optimization[C]//Advances in Neural Information Processing Systems. 2011: 873-881.</li>
<li>Lian X, Huang Y, Li Y, et al. Asynchronous parallel stochastic gradient for nonconvex optimization[C]//Advances in Neural Information Processing Systems. 2015: 2737-2745.</li>
<li>Recht B, Re C, Wright S, et al. Hogwild: A lock-free approach to parallelizing stochastic gradient descent[C]//Advances in neural information processing systems. 2011: 693-701.</li>
</ul>
<h3 id="量化压缩基本模型">量化压缩基本模型</h3>
<p>作者对分布式机器学习（特别是参数服务器架构）和量化压缩数学模型简单做了介绍</p>
<h4 id="分布式机器学习基本模型">分布式机器学习基本模型</h4>
<p><span class="math display">\[
\min _{\boldsymbol{x}} f(\boldsymbol{x})=\frac{1}{n} \sum_{i=1}^{n} \mathbb{E}_{\boldsymbol{\zeta} \sim \mathcal{D}_{i}} F(\boldsymbol{x} ; \boldsymbol{\zeta})
\]</span></p>
<p>其中<span class="math inline">\(n\)</span>表示工作节点数量，<span class="math inline">\(\mathcal{D}_{i}\)</span>本地节点<span class="math inline">\(i\)</span>的数据分布，<span class="math inline">\(F(\boldsymbol{x} ; \boldsymbol{\zeta})\)</span>为本地损失函数。 <span class="math display">\[
\boldsymbol{g}^{(i)}=\nabla F\left(\boldsymbol{x} ; \boldsymbol{\zeta}^{(i)}\right)
\]</span> 各工作节点计算梯度 <span class="math display">\[
\boldsymbol{g}=\frac{1}{n} \sum_{i=1}^{n} \boldsymbol{g}^{(i)}
\]</span> 参数服务器对梯度进行聚合，以上是对分布式SGD算法的简单建模</p>
<h4 id="量化压缩">量化压缩</h4>
<p><span class="math inline">\(Q_{\omega}[\cdot]\)</span>代表压缩操作，以<span class="math inline">\(1Bits\)</span>方法为例，利用递归的方法更新压缩误差： <span class="math display">\[
\boldsymbol{\delta}^{(i)}=\boldsymbol{g}^{(i)}+\boldsymbol{\delta}^{(i)}-Q_{\omega}\left[\boldsymbol{g}^{(i)}+\boldsymbol{\delta}^{(i)}\right]
\]</span> 其中<span class="math inline">\(\left[\boldsymbol{g}^{(i)}+\boldsymbol{\delta}^{(i)}\right]\)</span>表示本轮计算得到的梯度<span class="math inline">\(g^{(i)}\)</span>和上一轮压缩误差<span class="math inline">\(\boldsymbol{\delta}^{(i)}\)</span>的和，上式子是对本轮量化误差的重新计算，这也是误差补偿的由来。</p>
<h4 id="主要贡献">主要贡献</h4>
<ol type="1">
<li>比其他没有错误补偿的压缩方法具有更好的收敛性</li>
<li>进一步优化了通信效率</li>
<li>第一次给出了误差补偿SGD相关算法的速率分析</li>
<li>在非凸情况下的加速证明</li>
</ol>
<h2 id="相关工作">相关工作</h2>
<h4 id="分布式学习">分布式学习</h4>
<h5 id="中心化并行训练">中心化并行训练</h5>
<h6 id="参数服务器架构">参数服务器架构</h6>
<ol type="1">
<li>Abadi M, Barham P, Chen J, et al. Tensorflow: A system for large-scale machine learning[C]//12th {USENIX} symposium on operating systems design and implementation ({OSDI} 16). 2016: 265-283.</li>
<li>Li M, Andersen D G, Park J W, et al. Scaling distributed machine learning with the parameter server[C]//11th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 14). 2014: 583-598.</li>
</ol>
<h6 id="去中心化训练">去中心化训练</h6>
<ol type="1">
<li>固定拓扑
<ul>
<li>Jin P H, Yuan Q, Iandola F, et al. How to scale distributed deep learning?[J]. arXiv preprint arXiv:1611.04581, 2016.</li>
<li>Lian X, Zhang C, Zhang H, et al. Can decentralized algorithms outperform centralized algorithms? a case study for decentralized parallel stochastic gradient descent[C]//Advances in Neural Information Processing Systems. 2017: 5330-5340.</li>
<li>Shen Z, Mokhtari A, Zhou T, et al. Towards more efficient stochastic decentralized learning: Faster convergence and sparse communication[J]. arXiv preprint arXiv:1805.09969, 2018.</li>
<li>Tang H, Lian X, Yan M, et al. D <span class="math inline">\(^ 2\)</span>: Decentralized Training over Decentralized Data[J]. arXiv preprint arXiv:1803.07068, 2018.</li>
</ul></li>
<li>随机拓扑
<ul>
<li>Lian X, Zhang W, Zhang C, et al. Asynchronous decentralized parallel stochastic gradient descent[C]//International Conference on Machine Learning. 2018: 3043-3052.</li>
<li>Nedić A, Olshevsky A. Distributed optimization over time-varying directed graphs[J]. IEEE Transactions on Automatic Control, 2014, 60(3): 601-615.</li>
<li>Nedic A, Olshevsky A, Shi W. Achieving geometric convergence for distributed optimization over time-varying graphs[J]. SIAM Journal on Optimization, 2017, 27(4): 2597-2633.</li>
</ul></li>
</ol>
<h6 id="不同角度实现分布式训练">不同角度实现分布式训练</h6>
<ol type="1">
<li>隐私分布式优化
<ul>
<li>Jayaraman B, Wang L, Evans D, et al. Distributed learning without distress: Privacy-preserving empirical risk minimization[C]//Advances in Neural Information Processing Systems. 2018: 6343-6354.</li>
</ul></li>
<li>自适应分布式ADMM
<ul>
<li>Xu Z, Taylor G, Li H, et al. Adaptive consensus ADMM for distributed optimization[J]. arXiv preprint arXiv:1706.02869, 2017.</li>
</ul></li>
<li>非平滑分布式优化
<ul>
<li>Scaman K, Bach F, Bubeck S, et al. Optimal algorithms for non-smooth distributed optimization in networks[C]//Advances in Neural Information Processing Systems. 2018: 2740-2749.</li>
</ul></li>
<li>分布式近端原对称对偶算法
<ul>
<li>Hong M, Hajinezhad D, Zhao M M. Prox-PDA: The proximal primal-dual algorithm for fast distributed nonconvex optimization and learning over networks[C]//International Conference on Machine Learning. 2017: 1529-1538.</li>
</ul></li>
<li>投影-free的分布式在线学习
<ul>
<li>Zhang W, Zhao P, Zhu W, et al. Projection-free distributed online learning in networks[C]//International Conference on Machine Learning. 2017: 4054-4062.</li>
</ul></li>
<li>平行倒推
<ul>
<li>Huo Z, Gu B, Yang Q, et al. Decoupled parallel backpropagation with convergence guarantee[J]. arXiv preprint arXiv:1804.10574, 2018.</li>
</ul></li>
</ol>
<h5 id="压缩通信学习">压缩通信学习</h5>
<ol type="1">
<li><p>稀疏化模型</p>
<ul>
<li>Wang J, Kolar M, Srebro N, et al. Efficient distributed learning with sparsity[C]//International Conference on Machine Learning. 2017: 3636-3645.</li>
</ul></li>
<li><p>梯度量化</p>
<ul>
<li>Shen Z, Mokhtari A, Zhou T, et al. Towards more efficient stochastic decentralized learning: Faster convergence and sparse communication[J]. arXiv preprint arXiv:1805.09969, 2018.</li>
</ul>
<p>QSGD</p>
<ul>
<li>Alistarh D, Grubic D, Li J, et al. QSGD: Communication-efficient SGD via gradient quantization and encoding[C]//Advances in Neural Information Processing Systems. 2017: 1709-1720.</li>
</ul>
<p>PCA压缩</p>
<ul>
<li>Garber D, Shamir O, Srebro N. Communication-efficient algorithms for distributed stochastic principal component analysis[J]. arXiv preprint arXiv:1702.08169, 2017.</li>
</ul>
<p><span class="math inline">\(1Bits\)</span>量化</p>
<ul>
<li>Seide F, Fu H, Droppo J, et al. 1-bit stochastic gradient descent and its application to data-parallel distributed training of speech dnns[C]//Fifteenth Annual Conference of the International Speech Communication Association. 2014.</li>
<li>Wen W, Xu C, Yan F, et al. Terngrad: Ternary gradients to reduce communication in distributed deep learning[C]//Advances in neural information processing systems. 2017: 1509-1519.</li>
</ul></li>
</ol>
<h5 id="错误补偿压缩">错误补偿压缩</h5>
<h6 id="bits量化"><span class="math inline">\(1Bits\)</span>量化</h6>
<ul>
<li>Seide F, Fu H, Droppo J, et al. 1-bit stochastic gradient descent and its application to data-parallel distributed training of speech dnns[C]//Fifteenth Annual Conference of the International Speech Communication Association. 2014.</li>
</ul>
<h6 id="二次优化">二次优化</h6>
<ul>
<li>Wu J, Huang W, Huang J, et al. Error compensated quantized SGD and its applications to large-scale distributed optimization[J]. arXiv preprint arXiv:1806.08054, 2018.</li>
</ul>
<h6 id="signsgd">SignSGD</h6>
<ul>
<li>Bernstein J, Wang Y X, Azizzadenesheli K, et al. signSGD: Compressed optimisation for non-convex problems[J]. arXiv preprint arXiv:1802.04434, 2018.</li>
<li>Alistarh D, Hoefler T, Johansson M, et al. The convergence of sparsified gradient methods[C]//Advances in Neural Information Processing Systems. 2018: 5973-5983.</li>
</ul>
<h2 id="算法介绍">算法介绍</h2>
<h3 id="算法描述">算法描述</h3>
<p>本文采用参数服务器架构描述该算法，但是算法的应用场景不仅限于参数服务器架构，在第<span class="math inline">\(t\)</span>次迭代，我们将该算法的关键步骤描述如下：</p>
<ul>
<li><strong>工作节点计算</strong></li>
</ul>
<p>每个节点<span class="math inline">\(i\)</span>计算本地随机梯度<span class="math inline">\(\nabla F\left(\boldsymbol{x}_{t} ; \boldsymbol{\zeta}_{t}^{(i)}\right)\)</span>，该梯度基于全局模型<span class="math inline">\(x_t\)</span>以及本地样本<span class="math inline">\(\boldsymbol{\zeta}_{t}^{(i)}\)</span>。这里的<span class="math inline">\(i\)</span>代表工作节点<span class="math inline">\(i\)</span>的索引，<span class="math inline">\(t\)</span>表示本轮的迭代次数</p>
<ul>
<li><strong>工作节点压缩</strong></li>
</ul>
<p>每个工作节点<span class="math inline">\(i\)</span>计算误差补偿随机梯度 <span class="math display">\[
\boldsymbol{\delta}_{t}^{(i)}=\boldsymbol{v}_{t}^{(i)}-Q_{\omega_{t}^{(i)}}\left[\boldsymbol{v}_{t}^{(i)}\right]
\]</span> 其中<span class="math inline">\(Q_{\omega_{t}^{(i)}}\left[\boldsymbol{v}_{t}^{(i)}\right]\)</span>表示压缩误差补偿随机梯度</p>
<ul>
<li><strong>参数服务器压缩</strong></li>
</ul>
<p>所有节点将计算所得的<span class="math inline">\(Q_{\omega_{t}^{(i)}}\left[\boldsymbol{v}_{t}^{(i)}\right]\)</span>量化梯度发送给参数服务器，参数服务器聚合所有量化梯度<span class="math inline">\(Q_{\omega_{t}^{(i)}}\left[\boldsymbol{v}_{t}^{(i)}\right]\)</span>，并且更新全局误差补偿随机梯度<span class="math inline">\(v_t\)</span>，根据以下式子对梯度误差<span class="math inline">\(\boldsymbol{\delta}_{t}\)</span>进行更新 <span class="math display">\[
\begin{array}{l}
\boldsymbol{v}_{t}=\boldsymbol{\delta}_{t-1}+\frac{1}{n} \sum_{i=1}^{n} Q_{\omega_{t}^{(i)}}\left[\boldsymbol{v}_{t}^{(i)}\right] \\
\boldsymbol{\delta}_{t}=\boldsymbol{v}_{t}-Q_{\omega_{t}}\left[\boldsymbol{v}_{t}\right]
\end{array}
\]</span></p>
<ul>
<li><strong>工作节点更新</strong></li>
</ul>
<p>参数服务器将<span class="math inline">\(Q_{\omega_{t}^{(i)}}\left[\boldsymbol{v}_{t}^{(i)}\right]\)</span>发送给所有工作节点，所有工作节点更新本地模型： <span class="math display">\[
\boldsymbol{x}_{t+1}=\boldsymbol{x}_{t}-\gamma Q_{\omega_{t}}\left[\boldsymbol{v}_{t}\right]
\]</span> 其中<span class="math inline">\(\gamma\)</span>表示学习率</p>
<h3 id="压缩选择">压缩选择</h3>
<p>该方法不像当前存在的方法，并不需要无偏压缩的限制（也就是<span class="math inline">\(\mathbb{E}_{\omega} Q_{\omega}[\boldsymbol{x}]=\boldsymbol{x}\)</span>）。所以选择压缩的方法是非常灵活的。论文例举了多种较为常用的压缩选项：</p>
<h4 id="随机量化">随机量化</h4>
<p>对于任意真实值<span class="math inline">\(z \in[a, b]\)</span>，其中<span class="math inline">\((a,b)\)</span>是定义好的低bit数值，<span class="math inline">\(z\)</span>会有<span class="math inline">\(\frac{b-z}{b-a}\)</span>的概率被压缩到<span class="math inline">\(a\)</span>,有<span class="math inline">\(\frac{z-a}{b-a}\)</span>的概率压缩到<span class="math inline">\(b\)</span>。这种压缩操作是无偏的。</p>
<h4 id="bits量化-1"><span class="math inline">\(1Bits\)</span>量化</h4>
<p>将<span class="math inline">\(x\)</span>向量压缩到<span class="math inline">\(\|x\| \operatorname{sign}(x)\)</span>，其中<span class="math inline">\(sign(x)\)</span>是其中<span class="math inline">\(x\)</span>向量对应元素的符号。这种压缩是有偏的</p>
<h4 id="clipping">Clipping</h4>
<p>对于真实值<span class="math inline">\(z\)</span>，直接设置低于<span class="math inline">\(k\)</span>bis的部分压缩到<span class="math inline">\(0\)</span>。例如，将<span class="math inline">\(1.23456\)</span>压缩为d<span class="math inline">\(1.2\)</span>，直接将其较低的四位变成<span class="math inline">\(0\)</span>。这种压缩是有偏的。</p>
<h4 id="top-k稀疏化">Top-k稀疏化</h4>
<p>对于向量<span class="math inline">\(x\)</span>，将其最大的<span class="math inline">\(k\)</span>个元素进行保留，其余的设置为<span class="math inline">\(0\)</span>。这种操作是有偏的。</p>
<h4 id="随机稀疏化">随机稀疏化</h4>
<p>对于真实值<span class="math inline">\(z\)</span>，有<span class="math inline">\(p\)</span>的概率将<span class="math inline">\(z\)</span>设置为<span class="math inline">\(0\)</span>，以及<span class="math inline">\(p\)</span>的概率设置为<span class="math inline">\(z/p\)</span>。这样的方法是无偏的</p>
<h2 id="数学证明和收敛性分析">数学证明和收敛性分析</h2>
<p>待补充...</p>
<h2 id="实验">实验</h2>
<h3 id="实验设置">实验设置</h3>
<h4 id="数据集和模型">数据集和模型</h4>
<ul>
<li>ResNet-18以及CIFAR-10</li>
</ul>
<h4 id="实现对照组">实现对照组</h4>
<h5 id="doublesqueeze">DOUBLESQUEEZE</h5>
<h6 id="bit压缩"><span class="math inline">\(1-bit\)</span>压缩</h6>
<p>将梯度压缩到<span class="math inline">\(1-bit\)</span>，只包含符号。基于向量考虑，它的比例因子表示为： <span class="math display">\[
\frac{\text { magnitude of compensated gradient }}{\text { magnitude of quantized gradient }}
\]</span></p>
<h6 id="top-k压缩">Top-k压缩</h6>
<h5 id="qsgd">QSGD</h5>
<p>工作节点将梯度压缩成三元表示，其中每个元素用<span class="math inline">\(\{-1,0,1\}\)</span>表示。假设在这个梯度向量各个元素中的最大绝对值为<span class="math inline">\(m\)</span>，对于任意一个元素<span class="math inline">\(e\)</span>，它都以<span class="math inline">\(|e| /|m|\)</span>的可能性压缩到<span class="math inline">\(sign(e)\)</span>，以<span class="math inline">\(1-|e| /|m|\)</span>的可能性压缩到<span class="math inline">\(0\)</span>。扩展因子可以记为： <span class="math display">\[
\frac{\text { magnitude of compensated gradient }}{\text { magnitude of quantized gradient }}
\]</span> 采用这种方法时，参数服务器将梯度分发的时候不会讲梯度再次压缩</p>
<h5 id="vanilla-sgd">Vanilla SGD</h5>
<p>并不采用任何压缩处理</p>
<h5 id="mem-sgd">MEM-SGD</h5>
<p>和DEOUBLESQUEEZE的区别是从参数服务器进行分发的梯度不进行压缩，对于此种方法，本文也去使用了<span class="math inline">\(1-bit\)</span>二和<span class="math inline">\(top-k\)</span>这两中压缩方法。</p>
<h5 id="top-k-sgd">Top-k SGD</h5>
<p>该方法不涉及误差补偿机制</p>
<h3 id="实验结果">实验结果</h3>
<ol type="1">
<li>将<span class="math inline">\(1-bit\)</span>压缩作为DEUBLESQUEEZE的压缩方法，与MEM-SGD, QSGD这些压缩方法做对比</li>
</ol>
<p><img src="/archives/493c0bc7/image-20200724191830893.png" alt="image-20200724191830893" style="zoom:67%;"></p>
<p><img src="/archives/493c0bc7/image-20200724192014337.png" alt="image-20200724192014337" style="zoom:67%;"></p>
<p><img src="/archives/493c0bc7/image-20200724192043966.png" alt="image-20200724192043966" style="zoom:67%;"></p>
<ol start="2" type="1">
<li>将Top-k压缩作为DEUBLESQUEEZE的压缩方法，与MEM-SGD, QSGD这些压缩方法做对比</li>
</ol>
<p><img src="/archives/493c0bc7/image-20200724192139291.png" alt="image-20200724192139291" style="zoom: 67%;"></p>
<p><img src="/archives/493c0bc7/image-20200724192150444.png" alt="image-20200724192150444" style="zoom: 67%;"></p>
<p><img src="/archives/493c0bc7/image-20200724192202959.png" alt="image-20200724192202959" style="zoom: 67%;"></p>
<div id="refer-anchor-1">

</div>
<ul>
<li>[1] <a href="http://papers.nips.cc/paper/6768-qsgd-communication-efficient-sgd-via-gradient-quantization-and-encoding.pdf" target="_blank" rel="noopener external nofollow noreferrer">Alistarh D, Grubic D, Li J, et al. QSGD: Communication-efficient SGD via gradient quantization and encoding[C]//Advances in Neural Information Processing Systems. 2017: 1709-1720.</a>
<div id="refer-anchor-2">

</div></li>
<li>[2] <a href="https://arxiv.org/pdf/1802.04434.pdf" target="_blank" rel="noopener external nofollow noreferrer">Bernstein J, Wang Y X, Azizzadenesheli K, et al. signSGD: Compressed Optimisation for Non-Convex Problems[C]//International Conference on Machine Learning. 2018: 560-569.</a>
<div id="refer-anchor-3">

</div></li>
<li>[3] <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/IS140694.pdf" target="_blank" rel="noopener external nofollow noreferrer">Seide F, Fu H, Droppo J, et al. 1-bit stochastic gradient descent and its application to data-parallel distributed training of speech dnns[C]//Fifteenth Annual Conference of the International Speech Communication Association. 2014.</a>
<div id="refer-anchor-4">

</div>
<div id="refer-anchor-5">

</div>
<div id="refer-anchor-6">

</div>
<div id="refer-anchor-7">

</div>
<div id="refer-anchor-8">

</div>
<div id="refer-anchor-9">

</div></li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
        <category>分布式机器学习</category>
        <category>通信优化</category>
        <category>梯度压缩</category>
      </categories>
      <tags>
        <tag>分布式机器学习</tag>
        <tag>通信优化</tag>
        <tag>梯度压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Kong和Keycloak第三方认证和权限管理</title>
    <url>/archives/fbb6b1b9.html</url>
    <content><![CDATA[<h2 id="介绍">介绍</h2>
<p>使用Keycloak作为第三方认证服务，Kong作为API网关与Keycloak进行对接，打通两者用户数据库，并使用Kong当中的ACL插件进行接口权限的设计。主要涉及到如下框架：</p>
<ul>
<li>Kong——开源API网关</li>
<li>Keycloak——一个OpenID认证服务</li>
<li>Konga——API网关后台管理可视化界面</li>
</ul>
<figure>
<img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-17.29.03-1595831384730.png" alt="Screen-Shot-2018-11-15-at-17.29.03"><figcaption>Screen-Shot-2018-11-15-at-17.29.03</figcaption>
</figure>
<p>下文将记录Kong、Konga和Keycloak三者的安装和对接过程，并介绍权限打通的设计思路。以下是主要步骤：</p>
<ol type="1">
<li>创建Dockerfile，创建带有kong-oidc插件的镜像</li>
<li>构建上述镜像</li>
<li>创建<code>docker-compose.yml</code>文件，配置Kong，Konga和Keycloak的相关信息</li>
<li>启动kong-db服务</li>
<li>运行<code>migrations</code></li>
<li>启动Kong服务</li>
<li>验证kong-oidc插件是否可用</li>
<li>使用StreamSet打通Keycloak和Kong用户数据库，进行数据同步</li>
<li>添加kong-oidc插件和ACL插件</li>
<li>测试认证是否可行</li>
</ol>
<h2 id="安装过程">安装过程</h2>
<h3 id="创建dockerfile文件">创建Dockerfile文件</h3>
<p>第一，我们需要创建有关于Kong的镜像。我们还需要在这个镜像的基础上安装kong-oidc插件。我们可以采用以下两种方法进行:</p>
<ol type="1">
<li>修改现有的、正在运行的容器并提交更改</li>
<li>创建Dockerfile文件，并镜像构建</li>
</ol>
<p>我们将采用第二种方法，以下是Dockerfile文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p docker/kong</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch docker/kong/Dockerfile</span></span><br></pre></td></tr></table></figure>
<p>使用vim创建并打开文件，写入以下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> kong:<span class="number">1.4</span>.<span class="number">2</span>-centos</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">"Centos 7 + Kong 1.4.2 + kong-oidc plugin"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y git unzip &amp;&amp; yum clean all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> luarocks install kong-oidc</span></span><br></pre></td></tr></table></figure>
<p>以上代码将会将安装kong1.4.2版本，以及在此基础上安装kong-oidc插件，接下来构建该文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t kong:1.4.2-centos-oidc docker/kong/</span></span><br></pre></td></tr></table></figure>
<p>如果遇到<code>Warning: The directory '/root/.cache/luarocks' or its parent directory is not owned by the current user</code>就忽略。</p>
<h3 id="安装及配置kong">安装及配置Kong</h3>
<p>接下来创建<code>docker-compose.yml</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch docker-compose.yml</span></span><br></pre></td></tr></table></figure>
<p>打开这个文件，并进行如下配置</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'3.4'</span></span><br><span class="line"></span><br><span class="line">networks: </span><br><span class="line">  kong-net:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  kong-datastore:</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  kong-db:</span><br><span class="line">    image: postgres:<span class="number">9.6</span></span><br><span class="line">    volumes:</span><br><span class="line">      - kong-datastore:/var/lib/postgresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - kong-net</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"15432:5432"</span></span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB:       api-gw</span><br><span class="line">      POSTGRES_USER:     kong</span><br><span class="line">      POSTGRES_PASSWORD: kong</span><br><span class="line"></span><br><span class="line">  kong:</span><br><span class="line">    image: kong:<span class="number">1.4</span>.<span class="number">2</span>-centos-oidc</span><br><span class="line">    depends_on:</span><br><span class="line">      - kong-db</span><br><span class="line">    networks:</span><br><span class="line">      - kong-net</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"8000:8000"</span> <span class="comment"># Listener</span></span><br><span class="line">      - <span class="string">"8001:8001"</span> <span class="comment"># Admin API</span></span><br><span class="line">      - <span class="string">"8443:8443"</span> <span class="comment"># Listener  (SSL)</span></span><br><span class="line">      - <span class="string">"8444:8444"</span> <span class="comment"># Admin API (SSL)</span></span><br><span class="line">    environment:</span><br><span class="line">      KONG_DATABASE:         postgres</span><br><span class="line">      KONG_PG_HOST:          kong-db</span><br><span class="line">      KONG_PG_PORT:          <span class="number">5432</span></span><br><span class="line">      KONG_PG_DATABASE:      api-gw</span><br><span class="line">      KONG_PROXY_ACCESS_LOG: /dev/stdout</span><br><span class="line">      KONG_ADMIN_ACCESS_LOG: /dev/stdout</span><br><span class="line">      KONG_PROXY_ERROR_LOG:  /dev/stderr</span><br><span class="line">      KONG_ADMIN_ERROR_LOG:  /dev/stderr</span><br><span class="line">      KONG_PROXY_LISTEN:     <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8000</span>, <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8443</span> ssl</span><br><span class="line">      KONG_ADMIN_LISTEN:     <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8001</span>, <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8444</span> ssl</span><br><span class="line">      KONG_PLUGINS:          bundled,oidc</span><br></pre></td></tr></table></figure>
<p>接下来，采用下面的命令启动kong-db服务，其中<code>-d</code>是告诉docker在后台运行Docker Compose进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d kong-db</span></span><br></pre></td></tr></table></figure>
<p>验证服务是否已经启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br></pre></td></tr></table></figure>
<p>接下来将迁移kong-db数据库，采用<code>migrations</code>命令。下面这个命令将驱动一个kong服务，<code>-rm</code>表示该服务将在命令运行之后关闭。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose run --rm kong kong migrations up</span></span><br></pre></td></tr></table></figure>
<p>最后，我们将Kong启动，并且检查其运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d kong</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br></pre></td></tr></table></figure>
<p>检查Kong的管理API，检查OIDC插件是否可以在服务器上使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s http://localhost:8001 | jq .plugins.available_on_server.oidc</span></span><br></pre></td></tr></table></figure>
<p>将返回<code>true</code>。但是，虽然OIDC插件在Kong上可用，但是还没有配置Keycloak，实际上还不能进行API的保护。</p>
<p>至此为止，就完成了Kong的安装</p>
<hr>
<h3 id="安装konga可视化终端">安装Konga可视化终端</h3>
<p>Konga是开源的Kong可视化界面，方面API网关管理人员对Kong进行可视化管理，安装方法和Kong类似。</p>
<p>配置<code>docker-compose.yml</code>文件，添加如下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">konga-prepare:</span><br><span class="line">     image: pantsel/konga:next</span><br><span class="line">     command: <span class="string">"-c prepare -a postgres -u postgresql://kong:kong@kong-db:5432/konga_db"</span></span><br><span class="line">     networks:</span><br><span class="line">       - kong-net</span><br><span class="line">     restart: on-failure</span><br><span class="line">     links:</span><br><span class="line">       - kong-db</span><br><span class="line">     depends_on:</span><br><span class="line">       - kong-db</span><br></pre></td></tr></table></figure>
<p>首先将konga的postgresql数据启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d konga-prepare</span></span><br></pre></td></tr></table></figure>
<p>检查是否启动成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br></pre></td></tr></table></figure>
<p>接下来在<code>docker-compose.yml</code>再配置Konga镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">konga:</span><br><span class="line">    image: pantsel/konga:latest</span><br><span class="line">    networks:</span><br><span class="line">      - kong-net</span><br><span class="line">    environment:</span><br><span class="line">      DB_ADAPTER: postgres</span><br><span class="line">      DB_HOST: kong-db</span><br><span class="line">      DB_USER: kong</span><br><span class="line">      DB_DATABASE: konga_db</span><br><span class="line">      NODE_ENV: production</span><br><span class="line">      DB_PASSWORD: kong</span><br><span class="line">    depends_on: </span><br><span class="line">      - kong-db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"1337:1337"</span></span><br></pre></td></tr></table></figure>
<p>再次启动konga</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d konga</span></span><br></pre></td></tr></table></figure>
<p>检查是否启动成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br></pre></td></tr></table></figure>
<p>用浏览器访问“IP地址:1337”端口，注册后台管理用户名密码，检查是否能够正常访问，进入后台管理界面后，配置和Kong的对接：</p>
<p><img src="/archives/fbb6b1b9/image-20200727141443389.png" alt="image-20200727141443389" style="zoom:67%;"></p>
<p>对接完成后，可以用Konga查看并配置Kong网关的信息了。</p>
<h3 id="安装keycloak">安装Keycloak</h3>
<p>本节欸将重点配置Keycloak的安装。我们还是采用docker对Keycloak进行安装。</p>
<figure>
<img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-19.38.47.png" alt="Screen-Shot-2018-11-15-at-19.38.47"><figcaption>Screen-Shot-2018-11-15-at-19.38.47</figcaption>
</figure>
<p>在本节中，我们将运行以下步骤：</p>
<ol type="1">
<li>修改<code>docker-compose.yml</code>来添加Keycloak和它的可视化终端服务</li>
<li>注册Keycloak数据库服务</li>
<li>注册Keycloak服务</li>
<li>登录Keycloak</li>
<li>为Kong添加Keycloak终端</li>
<li>添加新用户</li>
</ol>
<h4 id="使用docker安装keycloak">使用Docker安装Keycloak</h4>
<p>重新打开<code>docker-compose.yml</code>.为Keycloak添加网络：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">networks: </span><br><span class="line">  kong-net:</span><br><span class="line">  keycloak-net:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  kong-datastore:</span><br><span class="line">  keycloak-datastore:</span><br></pre></td></tr></table></figure>
<p>接下来将Keycloak数据库添加到<code>docker-compose.yml</code>中：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  ...</span><br><span class="line">  keycloak-db:</span><br><span class="line">    image: postgres:<span class="number">9.6</span></span><br><span class="line">    volumes: </span><br><span class="line">      - keycloak-datastore:/var/lib/postresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - keycloak-net</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"25432:5432"</span></span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_DB:       keycloak</span><br><span class="line">      POSTGRES_USER:     keycloak</span><br><span class="line">      POSTGRES_PASSWORD: password</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d keycloak-db</span></span><br></pre></td></tr></table></figure>
<p>验证是否可以使用（确保它的状态是启动的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br></pre></td></tr></table></figure>
<p>下一步，将Keycloak添加到<code>docker-compose.yml</code>的services中：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  ...</span><br><span class="line">  keycloak:</span><br><span class="line">    image: jboss/keycloak:<span class="number">4.5</span>.<span class="number">0</span>.Final</span><br><span class="line">    depends_on:</span><br><span class="line">      - keycloak-db</span><br><span class="line">    networks:</span><br><span class="line">      - keycloak-net</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"8180:8080"</span></span><br><span class="line">    environment:</span><br><span class="line">      DB_VENDOR:   POSTGRES</span><br><span class="line">      DB_ADDR:     keycloak-db</span><br><span class="line">      DB_PORT:     <span class="number">5432</span></span><br><span class="line">      DB_DATABASE: keycloak</span><br><span class="line">      DB_USER:     keycloak</span><br><span class="line">      DB_PASSWORD: password</span><br><span class="line">      KEYCLOAK_USER:     admin</span><br><span class="line">      KEYCLOAK_PASSWORD: admin</span><br></pre></td></tr></table></figure>
<p>最后启动Keycloak服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d keycloak</span></span><br></pre></td></tr></table></figure>
<p>验证服务是否可用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br></pre></td></tr></table></figure>
<h4 id="添加客户端到keycloak中">添加客户端到Keycloak中</h4>
<p>点击Administration Console进入到控制台当中，此时需要输入用户名和密码：</p>
<p>在<code>Master</code>域下，创建客户端：</p>
<figure>
<img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-20.38.29.png" alt="Screen-Shot-2018-11-15-at-20.38.29"><figcaption>Screen-Shot-2018-11-15-at-20.38.29</figcaption>
</figure>
<p>在添加客户端页面，填写“客户端ID”为kong，点击保存按钮。</p>
<figure>
<img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-20.43.23.png" alt="Screen-Shot-2018-11-15-at-20.43.23"><figcaption>Screen-Shot-2018-11-15-at-20.43.23</figcaption>
</figure>
<p>在详情页面中，可以看到“Access Type”，我们需要选择的是“Confidential”，其中“Root URL”是“IP地址:8000”（Kong所接管的端口），以及“Valid Redirect URIs”填写“/*”就可以了，我们的设置如下：</p>
<figure>
<img src="/archives/fbb6b1b9/image-20200727135258550.png" alt="image-20200727135258550"><figcaption>image-20200727135258550</figcaption>
</figure>
<p>点击保存之后，在“Credentials”页面中会有对应的“Secret”，这个密钥是需要在Kong当中进行配置的</p>
<figure>
<img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-20.52.51.png" alt="Screen-Shot-2018-11-15-at-20.52.51"><figcaption>Screen-Shot-2018-11-15-at-20.52.51</figcaption>
</figure>
<h4 id="为keycloak添加用户">为Keycloak添加用户</h4>
<p>要添加用户，单击左侧侧边栏的“Users”选项卡，然后单击右侧的“add user”按钮</p>
<figure>
<img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-20.58.07.png" alt="Screen-Shot-2018-11-15-at-20.58.07"><figcaption>Screen-Shot-2018-11-15-at-20.58.07</figcaption>
</figure>
<p>在下一页，将“Username”设置为“用户”，并将“Email Enable”开关设置为“On”。然后，点击“Save”按钮。</p>
<p><img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-21.00.07.png" alt="Screen-Shot-2018-11-15-at-21.00.07" style="zoom:67%;"></p>
<p>点击“Credentials”选项卡，输入密码，确认，确保“Temporary”开关设置为“关闭”。然后，点击“Save”按钮。</p>
<p>至此，在Keycloak当中的配置已经完成了。</p>
<hr>
<h3 id="将kong和keycloak进行对接">将Kong和Keycloak进行对接</h3>
<p>接下来将配置Keycloak和Kong的对接部分</p>
<p><img src="/archives/fbb6b1b9/Screen-Shot-2018-11-15-at-21.06.44.png" alt="Screen-Shot-2018-11-15-at-21.06.44" style="zoom:67%;"></p>
<ol type="1">
<li><p>创建服务和路由（此处省略）</p></li>
<li><p>在全局范围内安装oidc插件</p>
<p>点击左侧“Plugin”后，再点击“ADD GLOBAL PLUGINS”，在Other当中，又OIDC插件，找到并点击“ADD PLUGIN”，会弹出如下表单，表单当中的条目信息可以参考：https://github.com/nokia/kong-oidc在GitHub上的首页。</p>
<p>其中以下几个需要重点关注：</p>
<ul>
<li>client_id：需要和Keycloak中创建的client_id对应一致</li>
<li>client_secret：需要需要和Keycloak中自动生成的secret一致</li>
<li>realm：默认就是Keycloak中的master域</li>
<li>redirect after logout uri：/</li>
<li>discovery：根据OIDC填写：http://XXXXXX:8180/auth/realms/master/.well-known/openid-configuration</li>
</ul></li>
<li><p>配置完成后，访问Kong接管的API接口，会自动跳转到Keycloak的登录界面，说明Keycloak和Kong对接完成</p>
<p><img src="/archives/fbb6b1b9/image-20200727142400435.png" alt="image-20200727142400435" style="zoom:67%;"></p></li>
</ol>
<h2 id="存在问题">存在问题</h2>
<p>官方给出了以上配置虽然打通了Kong和Keycloak，但是由于登录是Keycloak进行管理，采用的是Keycloak中的用户，而这些用户和Kong当中的“Consumer”是分离的，而且此时不能够通过Keycloak进行用户权限的管理。</p>
<p>如果将用户管理交给Keycloak，就会架空Kong当中的Consumer，最好是有办法将Kong中的Consumer和Keycloak中的User打通</p>
<h3 id="目标">目标</h3>
<ul>
<li>打通Keycloak和Kong中的用户表</li>
<li>能够使得ACL插件进行白名单和黑名单的访问控制</li>
</ul>
<h3 id="方法">方法</h3>
<ol type="1">
<li>使用ETL工具两者数据表，将ID和用户名进行同步</li>
<li>修改ACL插件使其能够获取到认证过后的<code>authenticated_consumer</code></li>
</ol>
<h3 id="操作步骤">操作步骤</h3>
<h4 id="etl工具同步">ETL工具同步</h4>
<p>此处过程省略</p>
<h4 id="修改acl插件">修改ACL插件</h4>
<p>在kong-oidc插件官方文档中，给出了<code>X-Userinfo</code>是被注入在请求头当中的，例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">X-Userinfo: &#123;"preferred_username":"alice","id":"60f65308-3510-40ca-83f0-e9c0151cc680","sub":"60f65308-3510-40ca-83f0-e9c0151cc680"&#125;</span><br></pre></td></tr></table></figure>
<p>而该插件同样在<code>ngx.ctx.authenticated_consumer</code>中设置了变量，他能够支持其他插件对认证通过用户进行操作，因此，可以让ACL获取该信息，利用该信息和现有“Consumer”做匹配。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ngx.ctx.authenticated_credential = &#123;</span><br><span class="line">    id = "60f65308-3510-40ca-83f0-e9c0151cc680",   -- sub field from Userinfo</span><br><span class="line">    username = "alice"                             -- preferred_username from Userinfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改如下：</p>
<ul>
<li><p>进入docker容器当中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it  容器ID /bin/bash</span></span><br></pre></td></tr></table></figure></li>
<li><p>进入Kong插件所在目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/share/lua/5.1/kong/plugins/acl</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开group.lua文件，对<code>get_current_consumer_id</code>做修改</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">local function get_current_consumer_id()</span><br><span class="line">  kong.log.err("oidc info:", ngx.ctx.authenticated_credential.id)</span><br><span class="line">  return (kong.client.get_consumer() or EMPTY).id or</span><br><span class="line">         (kong.client.get_credential() or EMPTY).consumer_id or</span><br><span class="line"><span class="addition">+        (ngx.ctx.authenticated_credential or EMPTY).id</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样就可以做到Kong和Keycloak真正打通。</p>
]]></content>
      <categories>
        <category>API网关</category>
        <category>Kong&amp;Konga</category>
        <category>权限认证</category>
      </categories>
      <tags>
        <tag>Kong</tag>
        <tag>keycloak</tag>
        <tag>权限认证</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/archives/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener external nofollow noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener external nofollow noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener external nofollow noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener external nofollow noreferrer">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener external nofollow noreferrer">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener external nofollow noreferrer">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener external nofollow noreferrer">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener external nofollow noreferrer">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/archives/d87f7e0c.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">请输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="5c31251553eaba323c3ef346aadd1c63f2f0bc339a1ee60ff0cc34731a2c43f4">8b59b3ba6fb9413419c7b1098984cf3b6e948d4e7f2f186d251530ef64c17210a324021f2883140bc6a3614c6a7fcfeb972babe4cfae463813928edc1ed4a2413347dc4e65ff506584f34afeb8f5a4bce055382dfd74c9cbfbd1d7b750962c27967a2f8655b12ff8f79512dcffc9c0d8de3174afa34fa9682697e073ea841f8933a8ad93e78114432c8f08234e4b304288bef7c1a277b0da8347f0168a70b871d7480cdc07990e441e545528168d27822421489be95cb01faa03a1499f45cf26ff27bf85c7d0f10856da92703ca3b30ad94d1b58cdf611629fa1e683f7ce1a50464dd914eff55e1f463239348470405bd075fc41f658f45648fdbb1f354fb363ec83210dfe723b373fb04d200589a28305c33811c171302cc106a3227d2d94bdeb78a6627c32d70ed79f95a991bbbf892cd78972d42c4f1f0dee65354bdf02bea786667116a7d79624cf3512f31877f252f8b5d21a8c7820946892d56c616bdce8191cbd5655cadfe829912dbc1c9dda94e7c8b2e7b119b649854b926adc37c8d3d0ee1fda4a9fc6e8d038e349dd363b5516724d2f66056ec0fbcfe7dcb22dc916abd8b68cf19ec90209145bd4e87102d64ede8ccdd28cae5a3b06fff96824d8ab2fe5cca3810427e85c87d8d52c8c981e59699f5d48c23009a56ed8d02820c41335ac5dfa104eaf69facd5e32d41c8230602e6f0517b956371415724b3b8bbade0555bd542f918f566b82e0cc9a76b9b918e9adcffc9c7cfe97a6c0948c3e9f371981dfba03cd1796eed1117e8e5db65b67c8c0b844abf2c5057d1ed659888ca4251b17010ec23182a0c3a553da3ec6995970b3df6d921ba3d668cacf9e799142622399bcc9f9e4eca5eb124d5e5107fd1d7fabaaa341b730a41fb3600484616a3292666b7614cb5e155e16d08d3dab6eec17774eb559e9e5e052937d1a8612d0994e20dba014eff4b3b0d913780a9d844b75131c89e6e0f684b270f52c16e5436f0c2919ea9b090f9577006d558e32461b7b6174274b1766585dfbb481a218cb345e84078343ca47b27bd92101268028bf063535b707a094304c215dad9d67500d36a964f4f8b2b5187d273dad913991fe4dd8b7fc75937f1fa6c04faeaf6538ee104fb5edb8de1a5e7d09ff7522d9aef6ea7e699d366ff914465762b612cc55e39fb990cccbc868ffcfb2e7f546de21fd30b8671be0a210fe32629df9f46d705f3f7e8e7d69db6bc23973f87f8f60569c7f5d2b029ac08ba4452b4fab6024114ebe9a23206a23718db612c5547875ea9ef84de53733b0f126e1ee3698fda6688db2044805f7b5e14ff6e19aaa19d234b0a5e32efcc6d2da2187bddee901098eda0631620c4e8e4a17883e32bdbeb22095124c6981d719e6d15fa9cbbf906b4fce9b724e707705c1bc9f4902c6f3384e6d59ec65316ef4e9cb82b74eafdcd4b569f8d75245bc0e6c14718a62c890d1e5c50c47b921ee12e4d948de16cf201472f632d17d4500fae925c8ecefd33960759dc995165889a5df933a6a7a5a5d310c0ebcd816ec10feb4c1222fc68bc337dc612d9b33e3531700eece020dda61e334dd7f682e240e02d47ab4adf7d51766</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>你好</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
